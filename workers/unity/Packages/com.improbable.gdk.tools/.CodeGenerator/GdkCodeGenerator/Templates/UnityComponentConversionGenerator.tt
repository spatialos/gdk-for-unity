<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#
    var fieldDetailsList = GetFieldDetailsList();
    var componentDetails = GetComponentDetails();
    var generatedHeader = CommonGeneratorUtils.GetGeneratedHeader();
    var commandDetailsList = GetCommandDetailsList();
    var eventDetailsList = GetEventDetailsList();
    var componentNamespace = qualifiedNamespace + "." + componentDetails.ComponentName;
    var profilingStart = $"Profiler.BeginSample(\"{componentDetails.ComponentName}\");";
    var profilingEnd = "Profiler.EndSample();";
#>
<#= generatedHeader #>

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Profiling;
using Unity.Mathematics;
using Unity.Entities;
using Unity.Collections;
using Improbable.Worker.CInterop;
using Improbable.Gdk.Core;
using Improbable.Gdk.Core.CodegenAdapters;
using Improbable.Gdk.Core.Commands;

namespace <#= qualifiedNamespace #>
{
    public partial class <#= componentDetails.ComponentName #>
    {
        internal class DispatcherHandler : ComponentDispatcherHandler
        {
            public override uint ComponentId => <#= componentDetails.ComponentId #>;

            private readonly EntityManager entityManager;

            private const string LoggerName = "<#= componentDetails.ComponentName #>.DispatcherHandler";

            public DispatcherHandler(WorkerSystem worker, World world) : base(worker, world)
            {
                entityManager = world.GetOrCreateManager<EntityManager>();
            }

            public override void Dispose()
            {
                <#= componentDetails.ComponentName #>.ReferenceTypeProviders.UpdatesProvider.CleanDataInWorld(World);
<# foreach (var fieldDetails in fieldDetailsList) { #>
<# if (!fieldDetails.IsBlittable) { #>
                <#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= fieldDetails.PascalCaseName #>Provider.CleanDataInWorld(World);
<# } #>
<# } #>
<# foreach (var eventDetails in eventDetailsList) { #>
                <#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= eventDetails.EventName #>Provider.CleanDataInWorld(World);
<# } #>
<# foreach (var commandDetails in commandDetailsList) { #>
                <#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= commandDetails.CommandName #>SenderProvider.CleanDataInWorld(World);
                <#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= commandDetails.CommandName #>RequestsProvider.CleanDataInWorld(World);
                <#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= commandDetails.CommandName #>ResponderProvider.CleanDataInWorld(World);
                <#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= commandDetails.CommandName #>ResponsesProvider.CleanDataInWorld(World);
<# } #>
            }

            public override void OnAddComponent(AddComponentOp op)
            {
                var entity = TryGetEntityFromEntityId(new EntityId(op.EntityId));

                <#= profilingStart #>
                var data = <#= componentNamespace #>.Serialization.Deserialize(op.Data.SchemaData.Value.GetFields(), World);
                data.MarkDataClean();
                entityManager.AddComponentData(entity, data);
                entityManager.AddComponent(entity, ComponentType.Create<NotAuthoritative<<#= componentNamespace #>.Component>>());

                var update = new <#= componentNamespace #>.Update
                {
<# foreach (var fieldDetails in fieldDetailsList) { #>
                    <#= fieldDetails.PascalCaseName #> = data.<#= fieldDetails.PascalCaseName #>,
<# } #>
                };

                var updates = new List<<#= componentNamespace #>.Update>
                {
                    update
                };

                var updatesComponent = new <#= componentNamespace #>.ReceivedUpdates
                {
                    handle = ReferenceTypeProviders.UpdatesProvider.Allocate(World)
                };

                ReferenceTypeProviders.UpdatesProvider.Set(updatesComponent.handle, updates);
                entityManager.AddComponentData(entity, updatesComponent);

                if (entityManager.HasComponent<ComponentRemoved<<#= componentNamespace #>.Component>>(entity))
                {
                    entityManager.RemoveComponent<ComponentRemoved<<#= componentNamespace #>.Component>>(entity);
                }
                else if (!entityManager.HasComponent<ComponentAdded<<#= componentNamespace #>.Component>>(entity))
                {
                    entityManager.AddComponent(entity, ComponentType.Create<ComponentAdded<<#= componentNamespace #>.Component>>());
                }
                else
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(ReceivedDuplicateComponentAdded)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, op.EntityId)
                        .WithField("Component", "<#= componentNamespace #>")
                    );
                }

                <#= profilingEnd #>
            }

            public override void OnRemoveComponent(RemoveComponentOp op)
            {
                var entity = TryGetEntityFromEntityId(new EntityId(op.EntityId));

                <#= profilingStart #>
<# if (!componentDetails.IsBlittable) { #>

                var data = entityManager.GetComponentData<<#= componentNamespace #>.Component>(entity);
<# foreach (var fieldDetails in fieldDetailsList) { #>
<# if (!fieldDetails.IsBlittable) { #>
                <#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= fieldDetails.PascalCaseName #>Provider.Free(data.<#= fieldDetails.CamelCaseName #>Handle);
<# } #>
<# } #>
<# } #>

                entityManager.RemoveComponent<<#= componentNamespace #>.Component>(entity);

                if (entityManager.HasComponent<ComponentAdded<<#= componentNamespace #>.Component>>(entity))
                {
                    entityManager.RemoveComponent<ComponentAdded<<#= componentNamespace #>.Component>>(entity);
                }
                else if (!entityManager.HasComponent<ComponentRemoved<<#= componentNamespace #>.Component>>(entity))
                {
                    entityManager.AddComponent(entity, ComponentType.Create<ComponentRemoved<<#= componentNamespace #>.Component>>());
                }
                else
                {
                    LogDispatcher.HandleLog(LogType.Error, new LogEvent(ReceivedDuplicateComponentRemoved)
                        .WithField(LoggingUtils.LoggerName, LoggerName)
                        .WithField(LoggingUtils.EntityId, op.EntityId)
                        .WithField("Component", "<#= componentNamespace #>")
                    );
                }

                <#= profilingEnd #>
            }

            public override void OnComponentUpdate(ComponentUpdateOp op)
            {
                var entity = TryGetEntityFromEntityId(new EntityId(op.EntityId));

                <#= profilingStart #>
                if (entityManager.HasComponent<NotAuthoritative<<#= componentNamespace #>.Component>>(entity))
                {
                    var data = entityManager.GetComponentData<<#= componentNamespace #>.Component>(entity);
                    <#= componentNamespace #>.Serialization.ApplyUpdate(op.Update.SchemaData.Value, ref data);
                    data.MarkDataClean();
                    entityManager.SetComponentData(entity, data);
                }

                var update = <#= componentNamespace #>.Serialization.DeserializeUpdate(op.Update.SchemaData.Value);

                List<<#= componentNamespace #>.Update> updates;
                if (entityManager.HasComponent<<#= componentNamespace #>.ReceivedUpdates>(entity))
                {
                    updates = entityManager.GetComponentData<<#= componentNamespace #>.ReceivedUpdates>(entity).Updates;
                }
                else
                {
                    updates = <#= componentNamespace #>.Update.Pool.Count > 0 ? <#= componentNamespace #>.Update.Pool.Pop() : new List<<#= componentNamespace #>.Update>();
                    var updatesComponent = new <#= componentNamespace #>.ReceivedUpdates
                    {
                        handle = ReferenceTypeProviders.UpdatesProvider.Allocate(World)
                    };
                    ReferenceTypeProviders.UpdatesProvider.Set(updatesComponent.handle, updates);
                    entityManager.AddComponentData(entity, updatesComponent);
                }

                updates.Add(update);

<# if (eventDetailsList.Count > 0) { #>
                var eventsObject = op.Update.SchemaData.Value.GetEvents();
<# foreach (var eventDetails in eventDetailsList) { #>
                {
                    var eventCount = eventsObject.GetObjectCount(<#= eventDetails.EventIndex #>);
                    if (eventCount > 0)
                    {
                        // Create component to hold received events
                        ReceivedEvents.<#= eventDetails.EventName #> eventsReceived;
                        List<<#= eventDetails.FqnPayloadType #>> eventList;
                        if (!entityManager.HasComponent<ReceivedEvents.<#= eventDetails.EventName #>>(entity))
                        {
                            eventsReceived = new ReceivedEvents.<#= eventDetails.EventName #>() {
                                handle = ReferenceTypeProviders.<#= eventDetails.EventName #>Provider.Allocate(World)
                            };
                            eventList = new List<<#= eventDetails.FqnPayloadType #>>((int) eventCount);
                            ReferenceTypeProviders.<#= eventDetails.EventName #>Provider.Set(eventsReceived.handle, eventList);
                            entityManager.AddComponentData(entity, eventsReceived);
                        }
                        else
                        {
                            eventsReceived = entityManager.GetComponentData<ReceivedEvents.<#= eventDetails.EventName #>>(entity);
                            eventList = eventsReceived.Events;
                        }

                        // Deserialize events onto component
                        for (uint i = 0; i < eventCount; i++)
                        {
                            var e = <#= eventDetails.FqnPayloadType #>.Serialization.Deserialize(eventsObject.IndexObject(<#= eventDetails.EventIndex #>, i));
                            eventList.Add(e);
                        }
                    }
                }

<# } #>
<# } #>
                <#= profilingEnd #>
            }

            public override void OnAuthorityChange(AuthorityChangeOp op)
            {
                var entityId = new EntityId(op.EntityId);
                var entity = TryGetEntityFromEntityId(entityId);

                <#= profilingStart #>
                ApplyAuthorityChange(entity, op.Authority, entityId);
                <#= profilingEnd #>
            }

            public override void AddCommandComponents(Unity.Entities.Entity entity)
            {
<# foreach (var commandDetails in commandDetailsList) { #>
                {
                    var commandSender = new <#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.CommandSenders.<#= commandDetails.CommandName #>();
                    commandSender.CommandListHandle = <#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= commandDetails.CommandName #>SenderProvider.Allocate(World);
                    commandSender.RequestsToSend = new List<<#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.<#= commandDetails.CommandName #>.Request>();

                    entityManager.AddComponentData(entity, commandSender);

                    var commandResponder = new <#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.CommandResponders.<#= commandDetails.CommandName #>();
                    commandResponder.CommandListHandle = <#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= commandDetails.CommandName #>ResponderProvider.Allocate(World);
                    commandResponder.ResponsesToSend = new List<<#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.<#= commandDetails.CommandName #>.Response>();

                    entityManager.AddComponentData(entity, commandResponder);
                }
<# } #>
            }

            private void ApplyAuthorityChange(Unity.Entities.Entity entity, Authority authority, global::Improbable.Gdk.Core.EntityId entityId)
            {
                switch (authority)
                {
                    case Authority.Authoritative:
                        if (!entityManager.HasComponent<NotAuthoritative<<#= componentNamespace #>.Component>>(entity))
                        {
                            LogInvalidAuthorityTransition(Authority.Authoritative, Authority.NotAuthoritative, entityId);
                            return;
                        }

                        entityManager.RemoveComponent<NotAuthoritative<<#= componentNamespace #>.Component>>(entity);
                        entityManager.AddComponent(entity, ComponentType.Create<Authoritative<<#= componentNamespace #>.Component>>());

                        // Add event senders
<# foreach (var eventDetail in eventDetailsList) { #>
                        {
                            var eventSender = new EventSender.<#= eventDetail.EventName #>()
                            {
                                handle = ReferenceTypeProviders.<#= eventDetail.EventName #>Provider.Allocate(World)
                            };
                            ReferenceTypeProviders.<#= eventDetail.EventName #>Provider.Set(eventSender.handle, new List<<#= eventDetail.FqnPayloadType #>>());
                            entityManager.AddComponentData(entity, eventSender);
                        }
<# } #>
                        break;
                    case Authority.AuthorityLossImminent:
                        if (!entityManager.HasComponent<Authoritative<<#= componentNamespace #>.Component>>(entity))
                        {
                            LogInvalidAuthorityTransition(Authority.AuthorityLossImminent, Authority.Authoritative, entityId);
                            return;
                        }

                        entityManager.AddComponent(entity, ComponentType.Create<AuthorityLossImminent<<#= componentNamespace #>.Component>>());
                        break;
                    case Authority.NotAuthoritative:
                        if (!entityManager.HasComponent<Authoritative<<#= componentNamespace #>.Component>>(entity))
                        {
                            LogInvalidAuthorityTransition(Authority.NotAuthoritative, Authority.Authoritative, entityId);
                            return;
                        }

                        if (entityManager.HasComponent<AuthorityLossImminent<<#= componentNamespace #>.Component>>(entity))
                        {
                            entityManager.RemoveComponent<AuthorityLossImminent<<#= componentNamespace #>.Component>>(entity);
                        }

                        entityManager.RemoveComponent<Authoritative<<#= componentNamespace #>.Component>>(entity);
                        entityManager.AddComponent(entity, ComponentType.Create<NotAuthoritative<<#= componentNamespace #>.Component>>());

                        // Remove event senders
<# foreach (var eventDetail in eventDetailsList) { #>
                        {
                            var eventSender = entityManager.GetComponentData<EventSender.<#= eventDetail.EventName #>>(entity);
                            ReferenceTypeProviders.<#= eventDetail.EventName #>Provider.Free(eventSender.handle);
                            entityManager.RemoveComponent<EventSender.<#= eventDetail.EventName #>>(entity);
                        }
<# } #>
                        break;
                }

                List<Authority> authorityChanges;
                if (entityManager.HasComponent<AuthorityChanges<<#= componentNamespace #>.Component>>(entity))
                {
                    authorityChanges = entityManager.GetComponentData<AuthorityChanges<<#= componentNamespace #>.Component>>(entity).Changes;

                }
                else
                {
                    var changes = new AuthorityChanges<<#= componentNamespace #>.Component>
                    {
                        Handle = AuthorityChangesProvider.Allocate(World)
                    };
                    AuthorityChangesProvider.Set(changes.Handle, new List<Authority>());
                    authorityChanges = changes.Changes;
                    entityManager.AddComponentData(entity, changes);
                }

                authorityChanges.Add(authority);
            }

            private void LogInvalidAuthorityTransition(Authority newAuthority, Authority expectedOldAuthority, global::Improbable.Gdk.Core.EntityId entityId)
            {
                LogDispatcher.HandleLog(LogType.Error, new LogEvent(InvalidAuthorityChange)
                    .WithField(LoggingUtils.LoggerName, LoggerName)
                    .WithField(LoggingUtils.EntityId, entityId.Id)
                    .WithField("New Authority", newAuthority)
                    .WithField("Expected Old Authority", expectedOldAuthority)
                    .WithField("Component", "<#= componentNamespace #>")
                );
            }
        }

        internal class ComponentReplicator : ComponentReplicationHandler
        {
            public override uint ComponentId => <#= componentDetails.ComponentId #>;

            public override EntityArchetypeQuery ComponentUpdateQuery => new EntityArchetypeQuery
            {
                All = new[]
                {
<# foreach (var eventDetail in eventDetailsList) { #>
                    ComponentType.Create<EventSender.<#= eventDetail.EventName #>>(),
<# } #>
                    ComponentType.Create<<#= componentNamespace #>.Component>(),
                    ComponentType.ReadOnly<Authoritative<<#= componentNamespace #>.Component>>(),
                    ComponentType.ReadOnly<SpatialEntityId>()
                },
                Any = Array.Empty<ComponentType>(),
                None = Array.Empty<ComponentType>(),
            };

            public override EntityArchetypeQuery[] CommandQueries => new EntityArchetypeQuery[]
            {
<# foreach (var commandDetails in commandDetailsList) { #>
                new EntityArchetypeQuery()
                {
                    All = new[]
                    {
                        ComponentType.Create<<#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.CommandSenders.<#= commandDetails.CommandName #>>(),
                        ComponentType.Create<<#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.CommandResponders.<#= commandDetails.CommandName #>>(),
                    },
                    Any = Array.Empty<ComponentType>(),
                    None = Array.Empty<ComponentType>(),
                },
<# } #>
            };

            public ComponentReplicator(EntityManager entityManager, Unity.Entities.World world) : base(entityManager)
            {
            }

            public override void ExecuteReplication(ComponentGroup replicationGroup, ComponentSystemBase system, global::Improbable.Worker.CInterop.Connection connection)
            {
                <#= profilingStart #>

                var chunkArray = replicationGroup.CreateArchetypeChunkArray(Allocator.TempJob);
                var spatialOSEntityType = system.GetArchetypeChunkComponentType<SpatialEntityId>(true);
                var componentType = system.GetArchetypeChunkComponentType<<#= componentNamespace #>.Component>();
<# foreach (var eventDetail in eventDetailsList) { #>
                var event<#= eventDetail.EventName #>Type = system.GetArchetypeChunkComponentType<EventSender.<#= eventDetail.EventName #>>(true);
<# } #>
                foreach (var chunk in chunkArray)
                {
                    var entityIdArray = chunk.GetNativeArray(spatialOSEntityType);
                    var componentArray = chunk.GetNativeArray(componentType);
<# foreach (var eventDetail in eventDetailsList) { #>
                    var event<#= eventDetail.EventName #>Array = chunk.GetNativeArray(event<#= eventDetail.EventName #>Type);
<# } #>
                    for (var i = 0; i < componentArray.Length; i++)
                    {
                        var data = componentArray[i];
                        var eventsToSend = 0;
<# foreach (var eventDetail in eventDetailsList) { #>
                        var events<#= eventDetail.EventName #> = event<#= eventDetail.EventName #>Array[i].Events;
                        eventsToSend += events<#= eventDetail.EventName #>.Count;
<# } #>

                        if (data.IsDataDirty() || eventsToSend > 0)
                        {
                            var update = new global::Improbable.Worker.CInterop.SchemaComponentUpdate(<#= componentDetails.ComponentId #>);
                            <#= componentNamespace #>.Serialization.SerializeUpdate(data, update);

<# if (eventDetailsList.Count > 0) { #>
                            // Serialize events
                            var eventsObject = update.GetEvents();
<# foreach (var eventDetail in eventDetailsList) { #>
                            if (events<#= eventDetail.EventName #>.Count > 0)
                            {
                                foreach (var e in events<#= eventDetail.EventName #>)
                                {
                                    var obj = eventsObject.AddObject(<#= eventDetail.EventIndex #>);
                                    <#= eventDetail.FqnPayloadType #>.Serialization.Serialize(e, obj);
                                }

                                events<#= eventDetail.EventName #>.Clear();
                            }

<# } #>
<# } #>
                            // Send serialized update over the wire
                            connection.SendComponentUpdate(entityIdArray[i].EntityId.Id, new global::Improbable.Worker.CInterop.ComponentUpdate(update), UpdateParameters);

                            data.MarkDataClean();
                            componentArray[i] = data;
                        }
                    }
                }

                chunkArray.Dispose();
                <#= profilingEnd #>
            }

            public override void SendCommands(ComponentGroup commandGroup, ComponentSystemBase system, World world, global::Improbable.Worker.CInterop.Connection connection)
            {
<# if (commandDetailsList.Count > 0) { #>
                <#= profilingStart #>
                var entityType = system.GetArchetypeChunkEntityType();
<#
for (var i = 0; i < commandDetailsList.Count; i++) {
    var commandDetails = commandDetailsList[i];
    var commandSenderType = $"{qualifiedNamespace}.{componentDetails.ComponentName}.CommandSenders.{commandDetails.CommandName}";
    var commandResponderType = $"{qualifiedNamespace}.{componentDetails.ComponentName}.CommandResponders.{commandDetails.CommandName}";
#>
                {
                    var commandSystem = world.GetExistingManager<CommandSystem>();

                    var senderType = system.GetArchetypeChunkComponentType<<#= commandSenderType #>>(true);
                    var responderType = system.GetArchetypeChunkComponentType<<#= commandResponderType #>>(true);

                    var chunks = commandGroup.CreateArchetypeChunkArray(Allocator.TempJob);
                    foreach (var chunk in chunks)
                    {
                        var entities = chunk.GetNativeArray(entityType);
                        var senders = chunk.GetNativeArray(senderType);
                        var responders = chunk.GetNativeArray(responderType);
                        for (var i = 0; i < senders.Length; i++)
                        {
                            var requests = senders[i].RequestsToSend;
                            var responses = responders[i].ResponsesToSend;
                            if (requests.Count > 0)
                            {
                                foreach (var request in requests)
                                {
                                    commandSystem.SendCommand(request, entities[i]);
                                }

                                requests.Clear();
                            }

                            if (responses.Count > 0)
                            {
                                foreach (var response in responses)
                                {
                                    commandSystem.SendResponse(response);
                                }

                                responses.Clear();
                            }
                        }
                    }

                    chunks.Dispose();
                }
<# } #>

                <#= profilingEnd #>
<# } #>
            }
        }

<# foreach (var command in commandDetailsList) {
        var requestType = command.CommandName + ".Request";
        var receivedRequestType = command.CommandName + ".ReceivedRequest";
        var responseType = command.CommandName + ".Response";
        var receivedResponseType = command.CommandName + ".ReceivedResponse";

        var commandResponseBufferType = $"{qualifiedNamespace}.{componentDetails.ComponentName}.CommandResponses.{command.CommandName}";
        var commandRequestBufferType = $"{qualifiedNamespace}.{componentDetails.ComponentName}.CommandRequests.{command.CommandName}";
#>
        public class <#= command.CommandName #>CommandComponentManager : ICommandComponentManager
        {
            public void PopulateCommandComponents(CommandSystem commandSystem, EntityManager entityManager, WorkerSystem workerSystem, World world)
            {
                var receivedRequests = commandSystem.GetRequests<<#= receivedRequestType #>>();
                // todo Not efficient if it keeps jumping all over entities but don't care right now
                foreach (var request in receivedRequests)
                {
                    if (!workerSystem.TryGetEntity(request.EntityId, out var entity))
                    {
                        continue;
                    }

                    List<<#= receivedRequestType #>> requests;
                    if (entityManager.HasComponent<<#= commandRequestBufferType #>>(entity))
                    {
                        requests = entityManager.GetComponentData<<#= commandRequestBufferType #>>(entity).Requests;
                    }
                    else
                    {
                        var data = new <#= commandRequestBufferType #>
                        {
                            CommandListHandle = <#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= command.CommandName #>RequestsProvider.Allocate(world)
                        };
                        data.Requests = new List<<#= receivedRequestType #>>();
                        requests = data.Requests;
                        entityManager.AddComponentData(entity, data);
                    }

                    requests.Add(request);
                }


                var receivedResponses = commandSystem.GetResponses<<#= receivedResponseType #>>();
                // todo Not efficient if it keeps jumping all over entities but don't care right now
                foreach (var response in receivedResponses)
                {
                    if (response.SendingEntity == Unity.Entities.Entity.Null || !entityManager.Exists(response.SendingEntity))
                    {
                        continue;
                    }

                    List<<#= receivedResponseType #>> responses;
                    if (entityManager.HasComponent<<#= commandResponseBufferType #>>(response.SendingEntity))
                    {
                        responses = entityManager.GetComponentData<<#= commandResponseBufferType #>>(response.SendingEntity).Responses;
                    }
                    else
                    {
                        var data = new <#= commandResponseBufferType #>
                        {
                            CommandListHandle = <#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= command.CommandName #>ResponsesProvider.Allocate(world)
                        };
                        data.Responses = new List<<#= receivedResponseType #>>();
                        responses = data.Responses;
                        entityManager.AddComponentData(response.SendingEntity, data);
                    }

                    responses.Add(response);
                }
            }
        }

<# } #>
<# foreach (var command in commandDetailsList) {
        var requestType = command.CommandName + ".Request";
        var receivedRequestType = command.CommandName + ".ReceivedRequest";
        var responseType = command.CommandName + ".Response";
        var receivedResponseType = command.CommandName + ".ReceivedResponse";
#>

        public class <#= command.CommandName #>CommandManager :
            ICommandRequestReceiver<<#= receivedRequestType #>>,
            ICommandRequestSender<<#= requestType #>>,
            ICommandResponseSender<<#= responseType #>>,
            ICommandResponseReceiver<<#= receivedResponseType #>>
        {
            private readonly Improbable.Worker.Core.CommandParameters shortCircuitingParameters = new CommandParameters
            {
                AllowShortCircuiting = true
            };

            private WorkerSystem workerSystem;
            private EntityManager entityManager;

            private List<(<#= requestType #> Request, long Id)> requestsToSend = new List<(<#= requestType #> Request, long Id)>();
            private List<<#= receivedRequestType #>> requestsReceived = new List<<#= receivedRequestType #>>();

            private List<<#= receivedResponseType #>> responsesReceived = new List<<#= receivedResponseType #>>();
            private List<<#= responseType #>> responsesToSend = new List<<#= responseType #>>();

            private Dictionary<long, <#= requestType #>> sentInternalRequestIdToRequest = new Dictionary<long, <#= requestType #>>();
            private Dictionary<long, Unity.Entities.Entity> sentInternalRequestIdToEntity = new Dictionary<long, Unity.Entities.Entity>();

            private Dictionary<long, long> sentWorkerRequestIdToInternalRequestId = new Dictionary<long, long>();

            public Type GetRequestType()
            {
                return typeof(<#= requestType #>);
            }

            public Type GetReceivedRequestType()
            {
                return typeof(<#= receivedRequestType #>);
            }

            public Type GetResponseType()
            {
                return typeof(<#= responseType #>);
            }

            public Type GetReceivedResponseType()
            {
                return typeof(<#= receivedResponseType #>);
            }

            public void SendAll()
            {
                var connection = workerSystem.Connection;

                foreach (var (request, id) in requestsToSend)
                {
                    var schemaCommandRequest = new global::Improbable.Worker.Core.SchemaCommandRequest(ComponentId, <#= command.CommandIndex #>);
                    <#= command.FqnRequestType #>.Serialization.Serialize(request.Payload, schemaCommandRequest.GetObject());

                    var requestId = connection.SendCommandRequest(request.TargetEntityId,
                        new global::Improbable.Worker.Core.CommandRequest(schemaCommandRequest),
                        request.TimeoutMillis,
                        request.AllowShortCircuiting ? shortCircuitingParameters : null);

                    sentWorkerRequestIdToInternalRequestId[requestId.Id] = id;
                }

                foreach (var response in responsesToSend)
                {
                    var requestId = new global::Improbable.Worker.Core.RequestId<IncomingCommandRequest>(response.RequestId);

                    if (response.FailureMessage != null)
                    {
                        // Send a command failure if the string is non-null.
                        connection.SendCommandFailure(requestId, response.FailureMessage);
                        continue;
                    }

                    var schemaCommandResponse = new global::Improbable.Worker.Core.SchemaCommandResponse(ComponentId, <#= command.CommandIndex #>);
                    <#= command.FqnResponseType #>.Serialization.Serialize(response.Payload.Value, schemaCommandResponse.GetObject());

                    connection.SendCommandResponse(requestId, new global::Improbable.Worker.Core.CommandResponse(schemaCommandResponse));
                }

                requestsToSend.Clear();
                requestsReceived.Clear();
                responsesReceived.Clear();
                responsesToSend.Clear();
            }

            public void Init(World world)
            {
                workerSystem = world.GetExistingManager<WorkerSystem>();

                if (workerSystem == null)
                {
                    throw new ArgumentException("World instance is not running a valid SpatialOS worker");
                }

                var dispatcher = world.GetExistingManager<SpatialOSReceiveSystem>().Dispatcher;

                dispatcher.OnCommandRequest(AddRequest);
                dispatcher.OnCommandResponse(AddResponse);
            }

            public long SendCommand(<#= requestType #> request, Unity.Entities.Entity entity)
            {
                var id = global::Improbable.Gdk.Core.CommandRequestIdGenerator.GetNext();
                requestsToSend.Add((request, id));
                sentInternalRequestIdToEntity.Add(id, entity);
                sentInternalRequestIdToRequest[id] = request;
                return id;
            }

            public void SendResponse(<#= responseType #> response)
            {
                responsesToSend.Add(response);
            }

            public List<(<#= requestType #> Request, long Id)> GetRequestsToSend()
            {
                return requestsToSend;
            }

            public List<<#= receivedRequestType #>> GetRequestsReceived()
            {
                return requestsReceived;
            }

            public List<<#= receivedRequestType #>> GetRequestsReceivedForEntityId(Improbable.Worker.EntityId entityId)
            {
                return null;
                // todo don't actually use this - decide if this function is needed or not and if so index things properly
                //return requestsReceived.Where(request => request.TargetId == entityId).ToList();
            }

            public List<<#= responseType #>> GetResponsesToSend()
            {
                return responsesToSend;
            }

            public List<<#= receivedResponseType #>> GetResponsesReceived()
            {
                return responsesReceived;
            }

            public List<<#= receivedResponseType #>> GetResponsesReceivedForEntity(Unity.Entities.Entity entity)
            {
                // todo don't actually use this - decide if this function is needed or not and if so index things properly
                return responsesReceived.Where(response =>
                {
                    if (!sentInternalRequestIdToEntity.TryGetValue(response.RequestId, out var entityForRequest))
                    {
                        return false;
                    }

                    return entityForRequest == entity;
                }).ToList();
                return null;
            }

            public bool TryGetResponseReceivedForRequestId(long requestId, out <#= receivedResponseType #> response)
            {
                foreach (var r in responsesReceived)
                {
                    if (r.RequestId == requestId)
                    {
                        response = r;
                        return true;
                    }
                }

                response = default(<#= receivedResponseType #>);
                return false;
            }

            private void AddRequest(CommandRequestOp op)
            {
                var componentId = op.Request.ComponentId;
                if (componentId != ComponentId)
                {
                    return;
                }

                var commandIndex = op.Request.CommandIndex;
                if (commandIndex != <#= command.CommandIndex #>)
                {
                    return;
                }

                var deserializedRequest = <#= command.FqnRequestType #>.Serialization.Deserialize(op.Request.SchemaData.Value.GetObject());

                var request = new <#= receivedRequestType #>(
                    op.EntityId,
                    op.RequestId.Id,
                    op.CallerWorkerId,
                    op.CallerAttributeSet,
                    deserializedRequest);

                requestsReceived.Add(request);
            }

            private void AddResponse(CommandResponseOp op)
            {
                var componentId = op.Response.ComponentId;
                if (componentId != ComponentId)
                {
                    return;
                }

                var commandIndex = op.Response.CommandIndex;
                if (commandIndex != <#= command.CommandIndex #>)
                {
                    return;
                }

                <#= command.FqnResponseType #>? rawResponse = null;
                if (op.StatusCode == StatusCode.Success)
                {
                    rawResponse = <#= command.FqnResponseType #>.Serialization.Deserialize(op.Response.SchemaData.Value.GetObject());
                }

                var internalRequestId = sentWorkerRequestIdToInternalRequestId[op.RequestId.Id];
                sentWorkerRequestIdToInternalRequestId.Remove(op.RequestId.Id);

                var sendingEntity = sentInternalRequestIdToEntity[internalRequestId];
                sentInternalRequestIdToEntity.Remove(internalRequestId);

                var request = sentInternalRequestIdToRequest[internalRequestId];
                sentInternalRequestIdToRequest.Remove(internalRequestId);

                var response = new <#= receivedResponseType #>(
                    sendingEntity,
                    op.EntityId,
                    op.Message,
                    op.StatusCode,
                    rawResponse,
                    request.Payload,
                    request.Context,
                    internalRequestId);

                responsesReceived.Add(response);
            }
        }
<# } #>

        internal class ComponentCleanup : ComponentCleanupHandler
        {
            public override EntityArchetypeQuery CleanupArchetypeQuery => new EntityArchetypeQuery
            {
                All = Array.Empty<ComponentType>(),
                Any = new ComponentType[]
                {
                    ComponentType.Create<ComponentAdded<<#= componentNamespace #>.Component>>(),
                    ComponentType.Create<ComponentRemoved<<#= componentNamespace #>.Component>>(),
                    ComponentType.Create<<#= componentNamespace #>.ReceivedUpdates>(),
                    ComponentType.Create<AuthorityChanges<<#= componentNamespace #>.Component>>(),
<# foreach (var eventDetails in eventDetailsList) { #>
                    ComponentType.Create<ReceivedEvents.<#= eventDetails.EventName #>>(),
<# } #>
<# foreach (var commandDetails in commandDetailsList) { #>
                    ComponentType.Create<CommandRequests.<#= commandDetails.CommandName #>>(),
                    ComponentType.Create<CommandResponses.<#= commandDetails.CommandName #>>(),
<# } #>
                },
                None = Array.Empty<ComponentType>(),
            };

            public override void CleanComponents(ComponentGroup group, ComponentSystemBase system,
                EntityCommandBuffer buffer)
            {
                var entityType = system.GetArchetypeChunkEntityType();
                var componentAddedType = system.GetArchetypeChunkComponentType<ComponentAdded<<#= componentNamespace #>.Component>>();
                var componentRemovedType = system.GetArchetypeChunkComponentType<ComponentRemoved<<#= componentNamespace #>.Component>>();
                var receivedUpdateType = system.GetArchetypeChunkComponentType<<#= componentNamespace #>.ReceivedUpdates>();
                var authorityChangeType = system.GetArchetypeChunkComponentType<AuthorityChanges<<#= componentNamespace #>.Component>>();
<#
for (var i = 0; i < eventDetailsList.Count; i++) {
var eventDetails = eventDetailsList[i];
#>
                var <#= eventDetails.CamelCaseEventName #>EventType = system.GetArchetypeChunkComponentType<ReceivedEvents.<#= eventDetails.EventName #>>();
<# } #>
<#
for (var j = 0; j < commandDetailsList.Count; j++) {
    var commandDetails = commandDetailsList[j];
#>

                var <#= commandDetails.CamelCaseCommandName #>RequestType = system.GetArchetypeChunkComponentType<CommandRequests.<#= commandDetails.CommandName #>>();
                var <#= commandDetails.CamelCaseCommandName #>ResponseType = system.GetArchetypeChunkComponentType<CommandResponses.<#= commandDetails.CommandName #>>();
<# } #>

                var chunkArray = group.CreateArchetypeChunkArray(Allocator.TempJob);

                foreach (var chunk in chunkArray)
                {
                    var entities = chunk.GetNativeArray(entityType);

                    // Updates
                    if (chunk.Has(receivedUpdateType))
                    {
                        var updateArray = chunk.GetNativeArray(receivedUpdateType);
                        for (int i = 0; i < entities.Length; ++i)
                        {
                            buffer.RemoveComponent<<#= componentNamespace #>.ReceivedUpdates>(entities[i]);
                            var updateList = updateArray[i].Updates;

                            // Pool update lists to avoid excessive allocation
                            updateList.Clear();
                            <#= componentNamespace #>.Update.Pool.Push(updateList);

                            ReferenceTypeProviders.UpdatesProvider.Free(updateArray[i].handle);
                        }
                    }

                    // Component Added
                    if (chunk.Has(componentAddedType))
                    {
                        for (int i = 0; i < entities.Length; ++i)
                        {
                            buffer.RemoveComponent<ComponentAdded<<#= componentNamespace #>.Component>>(entities[i]);
                        }
                    }

                    // Component Removed
                    if (chunk.Has(componentRemovedType))
                    {
                        for (int i = 0; i < entities.Length; ++i)
                        {
                            buffer.RemoveComponent<ComponentRemoved<<#= componentNamespace #>.Component>>(entities[i]);
                        }
                    }

                    // Authority
                    if (chunk.Has(authorityChangeType))
                    {
                        var authorityChangeArray = chunk.GetNativeArray(authorityChangeType);
                        for (int i = 0; i < entities.Length; ++i)
                        {
                            buffer.RemoveComponent<AuthorityChanges<<#= componentNamespace #>.Component>>(entities[i]);
                            AuthorityChangesProvider.Free(authorityChangeArray[i].Handle);
                        }
                    }

<#
for (var i = 0; i < eventDetailsList.Count; i++) {
var eventDetails = eventDetailsList[i];
#>
                    // <#= eventDetails.EventName #> Event
                    if (chunk.Has(<#= eventDetails.CamelCaseEventName #>EventType))
                    {
                        var <#= eventDetails.CamelCaseEventName #>EventArray = chunk.GetNativeArray(<#= eventDetails.CamelCaseEventName #>EventType);
                        for (int i = 0; i < entities.Length; ++i)
                        {
                            buffer.RemoveComponent<ReceivedEvents.<#= eventDetails.EventName #>>(entities[i]);
                            ReferenceTypeProviders.<#= eventDetails.EventName #>Provider.Free(<#= eventDetails.CamelCaseEventName #>EventArray[i].handle);
                        }
                    }

<# } #>
<#
for (var j = 0; j < commandDetailsList.Count; j++) {
    var commandDetails = commandDetailsList[j];
#>
                    // <#= commandDetails.CommandName #> Command
                    if (chunk.Has(<#= commandDetails.CamelCaseCommandName #>RequestType))
                    {
                            var <#= commandDetails.CamelCaseCommandName #>RequestArray = chunk.GetNativeArray(<#= commandDetails.CamelCaseCommandName #>RequestType);
                        for (int i = 0; i < entities.Length; ++i)
                        {
                            buffer.RemoveComponent<CommandRequests.<#= commandDetails.CommandName #>>(entities[i]);
                            ReferenceTypeProviders.<#= commandDetails.CommandName #>RequestsProvider.Free(<#= commandDetails.CamelCaseCommandName #>RequestArray[i].CommandListHandle);
                        }
                    }

                    if (chunk.Has(<#= commandDetails.CamelCaseCommandName #>ResponseType))
                    {
                        var <#= commandDetails.CamelCaseCommandName #>ResponseArray = chunk.GetNativeArray(<#= commandDetails.CamelCaseCommandName #>ResponseType);
                        for (int i = 0; i < entities.Length; ++i)
                        {
                            buffer.RemoveComponent<CommandResponses.<#= commandDetails.CommandName #>>(entities[i]);
                            ReferenceTypeProviders.<#= commandDetails.CommandName #>ResponsesProvider.Free(<#= commandDetails.CamelCaseCommandName #>ResponseArray[i].CommandListHandle);
                        }
                    }
<# } #>
                }

                chunkArray.Dispose();
            }
        }

        internal class AcknowledgeAuthorityLossHandler : AbstractAcknowledgeAuthorityLossHandler
        {
            public override EntityArchetypeQuery Query => new EntityArchetypeQuery
            {
                All = new ComponentType[]
                {
                    ComponentType.ReadOnly<AuthorityLossImminent<<#= componentNamespace #>.Component>>(),
                    ComponentType.ReadOnly<SpatialEntityId>()
                },
                Any = Array.Empty<ComponentType>(),
                None = Array.Empty<ComponentType>()
            };

            public override void AcknowledgeAuthorityLoss(ComponentGroup group, ComponentSystemBase system,
                Improbable.Worker.CInterop.Connection connection)
            {
                var authorityLossType = system.GetArchetypeChunkComponentType<AuthorityLossImminent<<#= componentNamespace #>.Component>>();
                var spatialEntityType = system.GetArchetypeChunkComponentType<SpatialEntityId>();

                var chunkArray = group.CreateArchetypeChunkArray(Allocator.TempJob);

                foreach (var chunk in chunkArray)
                {
                    var authorityArray = chunk.GetNativeArray(authorityLossType);
                    var spatialEntityIdArray = chunk.GetNativeArray(spatialEntityType);

                    for (int i = 0; i < authorityArray.Length; ++i)
                    {
                        if (authorityArray[i].AcknowledgeAuthorityLoss)
                        {
                            connection.SendAuthorityLossImminentAcknowledgement(spatialEntityIdArray[i].EntityId.Id,
                                <#= componentDetails.ComponentId #>);
                        }
                    }
                }

                chunkArray.Dispose();
            }
        }
    }
}
