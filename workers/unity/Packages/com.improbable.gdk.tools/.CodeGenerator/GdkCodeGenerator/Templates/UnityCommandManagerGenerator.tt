<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#
    var componentDetails = GetComponentDetails();
    var generatedHeader = CommonGeneratorUtils.GetGeneratedHeader();
    var commandDetailsList = GetCommandDetailsList();
#>
<#= generatedHeader #>

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Profiling;
using Unity.Mathematics;
using Unity.Entities;
using Unity.Collections;
using Improbable.Worker.CInterop;
using Improbable.Gdk.Core;
using Improbable.Gdk.Core.CodegenAdapters;
using Improbable.Gdk.Core.Commands;

namespace <#= qualifiedNamespace #>
{
    public partial class <#= componentDetails.ComponentName #>
    {
<# foreach (var command in commandDetailsList) {
        var requestType = command.CommandName + ".Request";
        var receivedRequestType = command.CommandName + ".ReceivedRequest";
        var responseType = command.CommandName + ".Response";
        var rawReceivedResponseType = command.CommandName + ".RawReceivedResponse";
        var receivedResponseType = command.CommandName + ".ReceivedResponse";
#>
        public class <#= command.CommandName #>CommandManager : IComponentCommandManager<
            <#= requestType #>, <#= responseType #>, <#= receivedRequestType #>, <#= receivedResponseType #>>
        {
            private readonly Improbable.Worker.CInterop.CommandParameters shortCircuitingParameters = new CommandParameters
            {
                AllowShortCircuiting = true
            };

            private WorkerSystem workerSystem;
            private EntityManager entityManager;

            private List<(<#= requestType #> Request, long Id)> requestsToSend = new List<(<#= requestType #> Request, long Id)>();
            private ReceivedMessageList<<#= receivedRequestType #>> requestsReceived = new ReceivedMessageList<<#= receivedRequestType #>>();

            private List<<#= responseType #>> responsesToSend = new List<<#= responseType #>>();
            private ReceivedMessageList<<#= rawReceivedResponseType #>> rawResponsesReceived = new ReceivedMessageList<<#= rawReceivedResponseType #>>();
            private ReceivedMessageList<<#= receivedResponseType #>> responsesReceived = new ReceivedMessageList<<#= receivedResponseType #>>();

            private Dictionary<long, <#= requestType #>> sentInternalRequestIdToRequest = new Dictionary<long, <#= requestType #>>();
            private Dictionary<long, Unity.Entities.Entity> sentInternalRequestIdToEntity = new Dictionary<long, Unity.Entities.Entity>();

            private Dictionary<long, long> sentWorkerRequestIdToInternalRequestId = new Dictionary<long, long>();

            public Type GetRequestType()
            {
                return typeof(<#= requestType #>);
            }

            public Type GetReceivedRequestType()
            {
                return typeof(<#= receivedRequestType #>);
            }

            public Type GetResponseType()
            {
                return typeof(<#= responseType #>);
            }

            public Type GetReceivedResponseType()
            {
                return typeof(<#= receivedResponseType #>);
            }


            public void ApplyAndCleanDiff(ViewDiff diff)
            {
                var diffStorage = (Diff<#= command.CommandName #>CommandStorage) diff.GetCommandDiffStorage(ComponentId, <#= command.CommandIndex #>);
                diffStorage.SwapAndClearMessageLists(ref requestsReceived);
                diffStorage.SwapAndClearMessageLists(ref rawResponsesReceived);

                for (int i = 0; i < rawResponsesReceived.Count; ++i)
                {
                    AddResponse(in rawResponsesReceived[i]);
                }
            }

            public void SendAll()
            {
                var connection = workerSystem.Connection;

                foreach (var (request, id) in requestsToSend)
                {
                    var schemaCommandRequest = new global::Improbable.Worker.CInterop.SchemaCommandRequest(ComponentId, <#= command.CommandIndex #>);
                    <#= command.FqnRequestType #>.Serialization.Serialize(request.Payload, schemaCommandRequest.GetObject());

                    var requestId = connection.SendCommandRequest(request.TargetEntityId.Id,
                        new global::Improbable.Worker.CInterop.CommandRequest(schemaCommandRequest),
                        <#= command.CommandIndex #>,
                        request.TimeoutMillis,
                        request.AllowShortCircuiting ? shortCircuitingParameters : null);

                    sentWorkerRequestIdToInternalRequestId[requestId] = id;
                }

                foreach (var response in responsesToSend)
                {
                    if (response.FailureMessage != null)
                    {
                        // Send a command failure if the string is non-null.
                        connection.SendCommandFailure((uint) response.RequestId, response.FailureMessage);
                        continue;
                    }

                    var schemaCommandResponse = new global::Improbable.Worker.CInterop.SchemaCommandResponse(ComponentId, <#= command.CommandIndex #>);
                    <#= command.FqnResponseType #>.Serialization.Serialize(response.Payload.Value, schemaCommandResponse.GetObject());

                    connection.SendCommandResponse((uint) response.RequestId, new global::Improbable.Worker.CInterop.CommandResponse(schemaCommandResponse));
                }

                requestsToSend.Clear();
                requestsReceived.Clear();
                responsesReceived.Clear();
                responsesToSend.Clear();
            }

            public void Init(World world)
            {
                workerSystem = world.GetExistingManager<WorkerSystem>();

                if (workerSystem == null)
                {
                    throw new ArgumentException("World instance is not running a valid SpatialOS worker");
                }
            }

            public long SendCommand(<#= requestType #> request, Unity.Entities.Entity entity)
            {
                var id = global::Improbable.Gdk.Core.CommandRequestIdGenerator.GetNext();
                requestsToSend.Add((request, id));
                sentInternalRequestIdToEntity.Add(id, entity);
                sentInternalRequestIdToRequest[id] = request;
                return id;
            }

            public void SendResponse(<#= responseType #> response)
            {
                // todo consider if empty strings should be treated as errors
                if (!response.Payload.HasValue && response.FailureMessage == null)
                {
                    throw new ArgumentException("Command responses must have either a non-null payload or a non-null error message");
                }

                responsesToSend.Add(response);
            }

            public List<(<#= requestType #> Request, long Id)> GetRequestsToSend()
            {
                return requestsToSend;
            }

            public ReceivedMessagesSpan<<#= receivedRequestType #>> GetRequestsReceived()
            {
                return new ReceivedMessagesSpan<<#= receivedRequestType #>>(requestsReceived);
            }

            public List<<#= responseType #>> GetResponsesToSend()
            {
                return responsesToSend;
            }

            public ReceivedMessagesSpan<<#= receivedResponseType #>> GetResponsesReceived()
            {
                return new ReceivedMessagesSpan<<#= receivedResponseType #>>(responsesReceived);
            }

            public bool TryGetResponseReceivedForRequestId(long requestId, out <#= receivedResponseType #> response)
            {
                var responseIndex = responsesReceived.GetResponseIndex(requestId);
                if (responseIndex < 0)
                {
                    response = default(<#= receivedResponseType #>);
                    return false;
                }

                response = responsesReceived[responseIndex];
                return true;
            }

            private void AddResponse(in <#= rawReceivedResponseType #> rawResponse)
            {
                var internalRequestId = sentWorkerRequestIdToInternalRequestId[rawResponse.RequestId];
                sentWorkerRequestIdToInternalRequestId.Remove(rawResponse.RequestId);

                var sendingEntity = sentInternalRequestIdToEntity[internalRequestId];
                sentInternalRequestIdToEntity.Remove(internalRequestId);

                var request = sentInternalRequestIdToRequest[internalRequestId];
                sentInternalRequestIdToRequest.Remove(internalRequestId);

                var response = new <#= receivedResponseType #>(
                    sendingEntity,
                    rawResponse.EntityId,
                    rawResponse.Message,
                    rawResponse.StatusCode,
                    rawResponse.ResponsePayload,
                    request.Payload,
                    request.Context,
                    internalRequestId);

                responsesReceived.Add(response);
            }
        }

<# } #>
    }
}
